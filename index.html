<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="M·ªôt tr√≤ ch∆°i t∆∞∆°ng t√°c gi√∫p ng∆∞·ªùi d√πng h·ªçc ti·∫øng Anh b·∫±ng c√°ch nghe c√¢u v√† s·∫Øp x·∫øp c√°c t·ª´ theo ƒë√∫ng th·ª© t·ª±." />
    <title>Nghe v√† x·∫øp t·ª´ th√†nh c√¢u</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Nunito', sans-serif;
      }
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-6px); }
        75% { transform: translateX(6px); }
      }
      .animate-shake {
        animation: shake 0.5s ease-in-out;
      }
      .animate-fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
    </style>
</head>
<body>
    <noscript>B·∫°n c·∫ßn b·∫≠t JavaScript ƒë·ªÉ ch·∫°y ·ª©ng d·ª•ng n√†y.</noscript>
    <div id="root"></div>

    <script type="module">
      import React from 'https://esm.sh/react@18.2.0';
      import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';

      const { useState, useCallback, useMemo, useRef, useEffect } = React;

      // --- From types.ts ---
      const GameState = {
        Start: 0,
        TopicSelection: 1,
        Playing: 2,
        Congrats: 3,
      };

      // --- From data/topics.ts ---
      const topics = {
        "My Ideal Neighbourhood": [
            { en: "What is your ideal neighbourhood like?", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa b·∫°n nh∆∞ th·∫ø n√†o? üèòÔ∏èü§î" },
            { en: "My ideal neighbourhood is a place where everyone talks to each other.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i m·ªçi ng∆∞·ªùi n√≥i chuy·ªán v·ªõi nhau. üó£Ô∏èü§ù" },
            { en: "My ideal neighbourhood is a place where people feel safe on the streets.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i m·ªçi ng∆∞·ªùi c·∫£m th·∫•y an to√†n tr√™n ƒë∆∞·ªùng ph·ªë. üëÆ‚Äç‚ôÄÔ∏èüëç" },
            { en: "My ideal neighbourhood is a place with good schools and libraries.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i c√≥ tr∆∞·ªùng h·ªçc v√† th∆∞ vi·ªán t·ªët. üè´üìö" },
            { en: "My ideal neighbourhood is a place with clean and wide streets.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i c√≥ ƒë∆∞·ªùng ph·ªë s·∫°ch s·∫Ω v√† r·ªông r√£i. ‚ú®üõ£Ô∏è" },
            { en: "My ideal neighbourhood is a place with rows of trees along the streets.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i c√≥ nh·ªØng h√†ng c√¢y d·ªçc theo ƒë∆∞·ªùng ph·ªë. üå≥" },
            { en: "My ideal neighbourhood is a place with convenient facilities: a hospital, a park, a school, a supermarket, a sport centre, a library and a post office.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i c√≥ c√°c ti·ªán √≠ch thu·∫≠n l·ª£i: b·ªánh vi·ªán, c√¥ng vi√™n, tr∆∞·ªùng h·ªçc, si√™u th·ªã, trung t√¢m th·ªÉ thao, th∆∞ vi·ªán v√† b∆∞u ƒëi·ªán. üè•üå≥üè´üõí" },
            { en: "My ideal neighbourhood is a place with more public transports and fewer personal vehicles.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† n∆°i c√≥ nhi·ªÅu ph∆∞∆°ng ti·ªán c√¥ng c·ªông v√† √≠t xe c√° nh√¢n h∆°n. üöåüöÜ" },
            { en: "What does your ideal neighborhood look like?", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa b·∫°n tr√¥ng nh∆∞ th·∫ø n√†o? ü§îüè°" },
            { en: "I do like nice houses with gardens and quiet streets.", vi: "T√¥i th√≠ch nh·ªØng ng√¥i nh√† ƒë·∫πp c√≥ v∆∞·ªùn v√† ƒë∆∞·ªùng ph·ªë y√™n tƒ©nh. üè°üå∑" },
            { en: "My ideal neighborhood is a place in the city where I can really feel comfortable and safe.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† m·ªôt n∆°i trong th√†nh ph·ªë m√† t√¥i c√≥ th·ªÉ c·∫£m th·∫•y th·ª±c s·ª± tho·∫£i m√°i v√† an to√†n. üèôÔ∏èüòå" },
            { en: "It's a place with wide streets and pavements where I can walk safely.", vi: "ƒê√≥ l√† m·ªôt n∆°i c√≥ nh·ªØng con ƒë∆∞·ªùng r·ªông v√† v·ªâa h√® n∆°i t√¥i c√≥ th·ªÉ ƒëi b·ªô an to√†n. üö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏è" },
            { en: "There are lots of car parks so that people can find parking easily.", vi: "C√≥ r·∫•t nhi·ªÅu b√£i ƒë·∫≠u xe ƒë·ªÉ m·ªçi ng∆∞·ªùi c√≥ th·ªÉ t√¨m ch·ªó ƒë·∫≠u xe d·ªÖ d√†ng. üÖøÔ∏èüöó" },
            { en: "Police officers control the streets and make people feel safe.", vi: "C·∫£nh s√°t ki·ªÉm so√°t ƒë∆∞·ªùng ph·ªë v√† l√†m cho m·ªçi ng∆∞·ªùi c·∫£m th·∫•y an to√†n. üëÆ‚Äç‚ôÇÔ∏èüöì" },
            { en: "Older people can spend their mornings in the park while younger ones can jump there.", vi: "Ng∆∞·ªùi l·ªõn tu·ªïi c√≥ th·ªÉ d√†nh bu·ªïi s√°ng trong c√¥ng vi√™n trong khi nh·ªØng ng∆∞·ªùi tr·∫ª h∆°n c√≥ th·ªÉ nh·∫£y nh√≥t ·ªü ƒë√≥. üë¥üëµü§∏‚Äç‚ôÇÔ∏è" },
            { en: "Children can walk or cycle to school.", vi: "Tr·∫ª em c√≥ th·ªÉ ƒëi b·ªô ho·∫∑c ƒë·∫°p xe ƒë·∫øn tr∆∞·ªùng. üö∂‚Äç‚ôÄÔ∏èüö≤" },
            { en: "There are shops for people to do their shopping and great restaurants to enjoy your meal.", vi: "C√≥ nh·ªØng c·ª≠a h√†ng ƒë·ªÉ m·ªçi ng∆∞·ªùi mua s·∫Øm v√† nh·ªØng nh√† h√†ng tuy·ªát v·ªùi ƒë·ªÉ th∆∞·ªüng th·ª©c b·ªØa ƒÉn c·ªßa b·∫°n. üõçÔ∏èüçΩÔ∏è" },
            { en: "How does my ideal neighborhood sound to you?", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i nghe c√≥ v·∫ª nh∆∞ th·∫ø n√†o ƒë·ªëi v·ªõi b·∫°n? üëÇüòä" },
            { en: "Would you enjoy living there?", vi: "B·∫°n c√≥ th√≠ch s·ªëng ·ªü ƒë√≥ kh√¥ng? ü§ó" },
            { en: "Is it in a busy city or in a quiet village?", vi: "N√≥ ·ªü trong m·ªôt th√†nh ph·ªë s·∫ßm u·∫•t hay trong m·ªôt ng√¥i l√†ng y√™n tƒ©nh? üèôÔ∏èüèûÔ∏è" },
            { en: "My ideal neighborhood is a quiet place in the village.", vi: "Khu ph·ªë l√Ω t∆∞·ªüng c·ªßa t√¥i l√† m·ªôt n∆°i y√™n tƒ©nh trong l√†ng. üèûÔ∏èüè°" },
            { en: "There are small cottages with beautiful gardens.", vi: "C√≥ nh·ªØng ng√¥i nh√† nh·ªè v·ªõi nh·ªØng khu v∆∞·ªùn xinh ƒë·∫πp. üè°üå∏" },
            { en: "There are lots of trees and flowers along the streets.", vi: "C√≥ r·∫•t nhi·ªÅu c√¢y v√† hoa d·ªçc theo c√°c con ƒë∆∞·ªùng. üå≥üå∑" },
            { en: "It is a place where neighbors know each other and talk to each other on the street.", vi: "ƒê√≥ l√† n∆°i h√†ng x√≥m bi·∫øt nhau v√† n√≥i chuy·ªán v·ªõi nhau tr√™n ƒë∆∞·ªùng. üëãüó£Ô∏è" },
            { en: "Children play happily in the streets or at the school playground or go swimming in the lake.", vi: "Tr·∫ª em vui ch∆°i tr√™n ƒë∆∞·ªùng ph·ªë ho·∫∑c t·∫°i s√¢n ch∆°i c·ªßa tr∆∞·ªùng ho·∫∑c ƒëi b∆°i trong h·ªì. ü§∏‚Äç‚ôÄÔ∏èüèä‚Äç‚ôÇÔ∏è" },
            { en: "There's a main street with nice little shops, a small cafe and the pizza house.", vi: "C√≥ m·ªôt con ƒë∆∞·ªùng ch√≠nh v·ªõi nh·ªØng c·ª≠a h√†ng nh·ªè xinh, m·ªôt qu√°n c√† ph√™ nh·ªè v√† m·ªôt ti·ªám pizza. üõçÔ∏è‚òïüçï" },
            { en: "The nearest city is a 15-minute drive.", vi: "Th√†nh ph·ªë g·∫ßn nh·∫•t c√°ch ƒë√≥ 15 ph√∫t l√°i xe. üöóüèôÔ∏è" }
        ],
        "Daily Routines & Hobbies": [
            { en: "People should work together because they can help each other and understand each other better.", vi: "M·ªçi ng∆∞·ªùi n√™n l√†m vi·ªác c√πng nhau v√¨ h·ªç c√≥ th·ªÉ gi√∫p ƒë·ª° v√† hi·ªÉu nhau h∆°n. ü§ù‚ù§Ô∏è" },
            { en: "People should work together because they can solve the problems faster.", vi: "M·ªçi ng∆∞·ªùi n√™n l√†m vi·ªác c√πng nhau v√¨ h·ªç c√≥ th·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ nhanh h∆°n. üí°üöÄ" },
            { en: "People should work together because they can have more amazing ideas.", vi: "M·ªçi ng∆∞·ªùi n√™n l√†m vi·ªác c√πng nhau v√¨ h·ªç c√≥ th·ªÉ c√≥ nhi·ªÅu √Ω t∆∞·ªüng tuy·ªát v·ªùi h∆°n. ‚ú®üß†" },
            { en: "He gets up at 8:00.", vi: "Anh ·∫•y th·ª©c d·∫≠y l√∫c 8:00. ‚è∞‚òÄÔ∏è" },
            { en: "We usually have lunch at 1:00.", vi: "Ch√∫ng t√¥i th∆∞·ªùng ƒÉn tr∆∞a l√∫c 1:00. üïõü•™" },
            { en: "Tom does his homework in the afternoon.", vi: "Tom l√†m b√†i t·∫≠p v·ªÅ nh√† v√†o bu·ªïi chi·ªÅu. üìö‚úçÔ∏è" },
            { en: "She helps a charity for children.", vi: "C√¥ ·∫•y gi√∫p m·ªôt t·ªï ch·ª©c t·ª´ thi·ªán cho tr·∫ª em. ‚ù§Ô∏èüëßüë¶" },
            { en: "In the evening, I play video games.", vi: "V√†o bu·ªïi t·ªëi, t√¥i ch∆°i tr√≤ ch∆°i ƒëi·ªán t·ª≠. üéÆüåÉ" },
            { en: "We watch TV in the afternoon.", vi: "Ch√∫ng t√¥i xem TV v√†o bu·ªïi chi·ªÅu. üì∫üõãÔ∏è" },
            { en: "I always take a shower in the morning.", vi: "T√¥i lu√¥n t·∫Øm v√†o bu·ªïi s√°ng. üöø‚òÄÔ∏è" },
            { en: "We brush our teeth in the morning.", vi: "Ch√∫ng t√¥i ƒë√°nh rƒÉng v√†o bu·ªïi s√°ng. ü¶∑‚ú®" },
            { en: "They go to the gym in the evening.", vi: "H·ªç ƒëi t·∫≠p gym v√†o bu·ªïi t·ªëi. üí™üèãÔ∏è‚Äç‚ôÄÔ∏è" },
            { en: "Ann likes playing board games.", vi: "Ann th√≠ch ch∆°i board games. üé≤‚ôüÔ∏è" },
            { en: "He hates doing jigsaw puzzles.", vi: "Anh ·∫•y gh√©t ch∆°i tr√≤ ch∆°i gh√©p h√¨nh. üß©üò†" },
            { en: "Keith likes hanging out with his friends at weekends.", vi: "Keith th√≠ch ƒëi ch∆°i v·ªõi b·∫°n b√® v√†o cu·ªëi tu·∫ßn. üòéüë´" },
            { en: "We don't like going shopping at the mall.", vi: "Ch√∫ng t√¥i kh√¥ng th√≠ch ƒëi mua s·∫Øm ·ªü trung t√¢m th∆∞∆°ng m·∫°i. üõçÔ∏èüëé" },
            { en: "They love going to the amusement park every Saturday evening.", vi: "H·ªç th√≠ch ƒë·∫øn c√¥ng vi√™n gi·∫£i tr√≠ v√†o m·ªói t·ªëi th·ª© B·∫£y. üé°üé¢‚ù§Ô∏è" },
            { en: "She works as a teacher.", vi: "C√¥ ·∫•y l√†m ngh·ªÅ gi√°o vi√™n. üë©‚Äçüè´Ïπ†Ìåê" },
            { en: "He buys books online.", vi: "Anh ·∫•y mua s√°ch tr·ª±c tuy·∫øn. üíªüìö" },
            { en: "She washes the car every Friday.", vi: "C√¥ ·∫•y r·ª≠a xe v√†o m·ªói th·ª© S√°u. üöóüí¶" },
            { en: "He chats online in the evenings.", vi: "Anh ·∫•y tr√≤ chuy·ªán tr·ª±c tuy·∫øn v√†o c√°c bu·ªïi t·ªëi. üíªüí¨" },
            { en: "She studies English on Mondays.", vi: "C√¥ ·∫•y h·ªçc ti·∫øng Anh v√†o c√°c ng√†y th·ª© Hai. üìöüá¨üáß" },
            { en: "We always have dinner at 18:00.", vi: "Ch√∫ng t√¥i lu√¥n ƒÉn t·ªëi l√∫c 18:00. üïïüçΩÔ∏è" },
            { en: "They watch TV in the evening.", vi: "H·ªç xem TV v√†o bu·ªïi t·ªëi. üì∫üåÉ" },
            { en: "We have music lessons on Mondays.", vi: "Ch√∫ng t√¥i c√≥ c√°c bu·ªïi h·ªçc nh·∫°c v√†o th·ª© Hai. üéµüéπ" },
            { en: "When I get home, I do some work for my parents and then we all have dinner at about 7:30.", vi: "Khi v·ªÅ nh√†, t√¥i l√†m m·ªôt s·ªë vi·ªác cho b·ªë m·∫π v√† sau ƒë√≥ c·∫£ nh√† ƒÉn t·ªëi v√†o kho·∫£ng 7:30. üè°üçΩÔ∏è" },
            { en: "It's a tiring day so I just have chat online after that for an hour.", vi: "ƒê√≥ l√† m·ªôt ng√†y m·ªát m·ªèi n√™n t√¥i ch·ªâ tr√≤ chuy·ªán tr·ª±c tuy·∫øn sau ƒë√≥ trong m·ªôt gi·ªù. üò©üíªüí¨" }
        ],
        "At School": [
            { en: "We walk back home after school.", vi: "Ch√∫ng t√¥i ƒëi b·ªô v·ªÅ nh√† sau gi·ªù h·ªçc. üö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏èüè´" },
            { en: "We walk to school every day.", vi: "Ch√∫ng t√¥i ƒëi b·ªô ƒë·∫øn tr∆∞·ªùng m·ªói ng√†y. üö∂‚Äç‚ôÄÔ∏èüè´" },
            { en: "Tom is never late for school.", vi: "Tom kh√¥ng bao gi·ªù ƒëi h·ªçc mu·ªôn. üèÉ‚Äç‚ôÇÔ∏èüí®" },
            { en: "The school year in Vietnam begins in September and ends in May.", vi: "NƒÉm h·ªçc ·ªü Vi·ªát Nam b·∫Øt ƒë·∫ßu v√†o th√°ng Ch√≠n v√† k·∫øt th√∫c v√†o th√°ng NƒÉm. üáªüá≥üè´üóìÔ∏è" },
            { en: "Most schools in Vietnam require uniform.", vi: "H·∫ßu h·∫øt c√°c tr∆∞·ªùng h·ªçc ·ªü Vi·ªát Nam ƒë·ªÅu y√™u c·∫ßu ƒë·ªìng ph·ª•c. üëïü•ã" },
            { en: "Primary school lasts for five years and students finish it at the age of eleven.", vi: "Tr∆∞·ªùng ti·ªÉu h·ªçc k√©o d√†i trong nƒÉm nƒÉm v√† h·ªçc sinh ho√†n th√†nh n√≥ ·ªü tu·ªïi m∆∞·ªùi m·ªôt. üè´üë¶üëß" },
            { en: "At the end of primary school, students go to secondary school.", vi: "K·∫øt th√∫c b·∫≠c ti·ªÉu h·ªçc, h·ªçc sinh l√™n trung h·ªçc c∆° s·ªü. üéìüè´" },
            { en: "Secondary school lasts four years and students finish it at the age of fifteen.", vi: "Tr∆∞·ªùng trung h·ªçc c∆° s·ªü k√©o d√†i b·ªën nƒÉm v√† h·ªçc sinh ho√†n th√†nh n√≥ ·ªü tu·ªïi m∆∞·ªùi lƒÉm. üè´üë®‚Äçüéìüë©‚Äçüéì" },
            { en: "After students complete four years of secondary school, they go to high school for three years.", vi: "Sau khi h·ªçc sinh ho√†n th√†nh b·ªën nƒÉm trung h·ªçc c∆° s·ªü, h·ªç h·ªçc trung h·ªçc ph·ªï th√¥ng trong ba nƒÉm. üè´üßë‚Äçüè´" },
            { en: "High school is for students aged sixteen to eighteen.", vi: "Tr∆∞·ªùng trung h·ªçc ph·ªï th√¥ng d√†nh cho h·ªçc sinh t·ª´ m∆∞·ªùi s√°u ƒë·∫øn m∆∞·ªùi t√°m tu·ªïi. üë®‚Äçüè´üë©‚Äçüè´" },
            { en: "Students can choose to do professional training after they finish high school.", vi: "H·ªçc sinh c√≥ th·ªÉ ch·ªçn h·ªçc ngh·ªÅ sau khi t·ªët nghi·ªáp trung h·ªçc ph·ªï th√¥ng. üë∑‚Äç‚ôÄÔ∏èüë©‚Äçüç≥" },
            { en: "I live in Alaska so my day is a bit different to most children.", vi: "T√¥i s·ªëng ·ªü Alaska n√™n ng√†y c·ªßa t√¥i h∆°i kh√°c so v·ªõi h·∫ßu h·∫øt tr·∫ª em. ‚ùÑÔ∏èüêª" },
            { en: "First of all, I get up at 5:30 in the morning and leave my house at 6:30.", vi: "Tr∆∞·ªõc h·∫øt, t√¥i th·ª©c d·∫≠y l√∫c 5:30 s√°ng v√† r·ªùi kh·ªèi nh√† l√∫c 6:30. ‚è∞üåÖ" },
            { en: "It takes 2:00 hours to get to school and I don't go on the bus.", vi: "M·∫•t 2 gi·ªù ƒë·ªÉ ƒë·∫øn tr∆∞·ªùng v√† t√¥i kh√¥ng ƒëi xe bu√Ωt. ‚è≥üöå‚ùå" },
            { en: "There is a boat that comes along the river and picks up the students 1 by 1.", vi: "C√≥ m·ªôt chi·∫øc thuy·ªÅn ƒëi d·ªçc s√¥ng v√† ƒë√≥n t·ª´ng h·ªçc sinh m·ªôt. üö§üèûÔ∏è" },
            { en: "In the middle of winter, we don't have any school at all.", vi: "V√†o gi·ªØa m√πa ƒë√¥ng, ch√∫ng t√¥i kh√¥ng ƒëi h·ªçc ch√∫t n√†o. ‚ùÑÔ∏èüè´‚ùå" },
            { en: "That's because the water in the river turns into ice.", vi: "ƒê√≥ l√† v√¨ n∆∞·ªõc tr√™n s√¥ng bi·∫øn th√†nh bƒÉng. üèûÔ∏èüßä" },
            { en: "Also at that time of year it's dark 24 hours a day.", vi: "V√†o th·ªùi ƒëi·ªÉm ƒë√≥ trong nƒÉm tr·ªùi c≈©ng t·ªëi 24 gi·ªù m·ªôt ng√†y. üåÉüåë" },
            { en: "Anyway, I usually get to school at 8:30 we leave again at 3:30 in the afternoon.", vi: "D√π sao th√¨, t√¥i th∆∞·ªùng ƒë·∫øn tr∆∞·ªùng l√∫c 8:30 v√† ch√∫ng t√¥i l·∫°i r·ªùi ƒëi l√∫c 3:30 chi·ªÅu. üè´üïí" }
        ]
      };


      // --- From hooks/useSpeechSynthesis.ts ---
      const useSpeechSynthesis = () => {
        const [isSpeaking, setIsSpeaking] = useState(false);
        const [voices, setVoices] = useState([]);
        const utteranceRef = useRef(null);

        const updateVoices = useCallback(() => {
          if ('speechSynthesis' in window) {
            const availableVoices = window.speechSynthesis.getVoices();
            const englishVoices = availableVoices.filter(voice => voice.lang.startsWith('en'));
            setVoices(englishVoices);
          }
        }, []);

        useEffect(() => {
          if ('speechSynthesis' in window) {
            updateVoices();
            window.speechSynthesis.onvoiceschanged = updateVoices;
            return () => {
              if (window.speechSynthesis) {
                window.speechSynthesis.onvoiceschanged = null;
              }
            }
          }
        }, [updateVoices]);

        const cancel = useCallback(() => {
          if (window.speechSynthesis) {
              window.speechSynthesis.cancel();
          }
        }, []);

        useEffect(() => {
          return () => {
              cancel();
          }
        }, [cancel]);

        const speak = useCallback((text, options = {}) => {
          cancel();
          
          if (!('speechSynthesis' in window)) {
              console.warn("Speech Synthesis not supported in this browser.");
              if (options.onEnd) options.onEnd();
              return;
          }
          
          const { rate = 1.0, onBoundary, onEnd, voice } = options;

          const utterance = new SpeechSynthesisUtterance(text);
          utterance.lang = 'en-US';
          utterance.rate = rate;
          if (voice) {
            utterance.voice = voice;
          }
          utteranceRef.current = utterance;

          utterance.onstart = () => setIsSpeaking(true);
          
          if (onBoundary) {
            utterance.onboundary = (event) => {
              if (event.name === 'word') {
                const words = text.split(' ');
                let cumulativeLength = 0;
                for (let i = 0; i < words.length; i++) {
                  cumulativeLength += words[i].length + 1; // Add length of word + 1 for the space
                  if (event.charIndex < cumulativeLength) {
                      onBoundary(i);
                      return; // Exit loop once the word is found
                  }
                }
              }
            };
          }

          utterance.onend = () => {
            setIsSpeaking(false);
            utteranceRef.current = null;
            if (onEnd) onEnd();
          };

          utterance.onerror = (event) => {
            if (event.error !== 'interrupted') {
              console.error('SpeechSynthesis Error:', event.error);
            }
            setIsSpeaking(false);
            utteranceRef.current = null;
            if (onEnd) onEnd();
          };
          
          setTimeout(() => {
              window.speechSynthesis.speak(utterance);
          }, 50);

        }, [cancel]);

        return { speak, cancel, isSpeaking, voices };
      };

      // --- From components/Fireworks.tsx ---
      const Fireworks = () => {
        const canvasRef = useRef(null);
        const animationFrameId = useRef();
        const particles = useRef([]);

        const createParticle = (x, y) => {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 6 + 2;
          return {
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            color: `hsl(${Math.random() * 360}, 100%, 70%)`,
            size: Math.random() * 3 + 1,
            life: 1,
            fade: 0.02,
          };
        };

        const createExplosion = () => {
          if (!canvasRef.current) return;
          const x = Math.random() * canvasRef.current.width;
          const y = Math.random() * canvasRef.current.height / 2;
          for (let i = 0; i < 50; i++) {
            particles.current.push(createParticle(x, y));
          }
        };

        const animate = () => {
          if (!canvasRef.current) return;
          const ctx = canvasRef.current.getContext('2d');
          if (!ctx) return;
          
          ctx.globalCompositeOperation = 'source-over';
          ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
          ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
          ctx.globalCompositeOperation = 'lighter';
          
          particles.current = particles.current.filter(p => p.life > 0);

          particles.current.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.05;
            p.life -= p.fade;
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.color.match(/\\d+/)?.[0]}, 100%, 70%, ${p.life})`;
            ctx.fill();
          });

          animationFrameId.current = requestAnimationFrame(animate);
        };

        useEffect(() => {
          const canvas = canvasRef.current;
          if (canvas) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const handleResize = () => {
              canvas.width = window.innerWidth;
              canvas.height = window.innerHeight;
            };
            window.addEventListener('resize', handleResize);
            
            const intervalIds = [];
            for(let i = 0; i < 5; i++) {
                intervalIds.push(setTimeout(() => createExplosion(), Math.random() * 1000));
            }
            const mainInterval = setInterval(createExplosion, 500 + Math.random() * 500);
            intervalIds.push(mainInterval);
            animate();
            return () => {
              window.removeEventListener('resize', handleResize);
              if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);
              intervalIds.forEach(clearInterval);
              particles.current = [];
            };
          }
        }, []);

        return React.createElement('canvas', { ref: canvasRef, className: "fixed top-0 left-0 w-full h-full pointer-events-none z-50" });
      };

      // --- From components/TopicCongratsScreen.tsx ---
      const TopicCongratsScreen = ({
        playerName, topicName, correctCount, totalCount, onPlayAgain, onChooseAnotherTopic,
      }) => {
        return React.createElement('div', { className: "relative flex flex-col items-center gap-6 text-center p-4 animate-fade-in" },
          React.createElement(Fireworks),
          React.createElement('div', { className: "text-2xl sm:text-3xl md:text-4xl text-green-600 font-extrabold" },
            React.createElement('p', null, "Ch√∫c m·ª´ng ", React.createElement('strong', { className: "text-purple-600" }, playerName), "!"),
            React.createElement('p', { className: "mt-2" }, `B·∫°n ƒë√£ ho√†n th√†nh ch·ªß ƒë·ªÅ "${topicName}".`)
          ),
          React.createElement('p', { className: "text-xl sm:text-2xl text-slate-700 font-semibold" }, `B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng ${correctCount}/${totalCount} c√¢u.`),
          React.createElement('div', { className: "flex flex-col sm:flex-row gap-4 mt-6 w-full max-w-md" },
            React.createElement('button', {
              onClick: onPlayAgain,
              className: "w-full p-4 text-xl rounded-2xl bg-blue-500 text-white font-bold transform hover:scale-105 hover:bg-blue-600 transition-all shadow-lg"
            }, "Ch∆°i l·∫°i ch·ªß ƒë·ªÅ n√†y"),
            React.createElement('button', {
              onClick: onChooseAnotherTopic,
              className: "w-full p-4 text-xl rounded-2xl bg-orange-500 text-white font-bold transform hover:scale-105 hover:bg-orange-600 transition-all shadow-lg"
            }, "Ch·ªçn ch·ªß ƒë·ªÅ kh√°c")
          )
        );
      };

      // --- From components/StartScreen.tsx ---
      const StartScreen = ({ onStart }) => {
        const [name, setName] = useState('');
        const handleStartClick = () => {
          if (name.trim()) {
            onStart(name.trim());
          } else {
            alert('Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n ƒë·ªÉ b·∫Øt ƒë·∫ßu!');
          }
        };
        const handleKeyPress = (event) => {
          if (event.key === 'Enter') handleStartClick();
        };

        return React.createElement('div', { className: "flex flex-col items-center gap-6 animate-fade-in" },
          React.createElement('input', {
            type: "text",
            value: name,
            onChange: (e) => setName(e.target.value),
            onKeyPress: handleKeyPress,
            placeholder: "Nh·∫≠p t√™n c·ªßa b·∫°n...",
            className: "font-nunito text-lg sm:text-xl p-3 px-5 rounded-2xl border-2 border-purple-400 text-center w-full max-w-sm focus:outline-none focus:ring-4 focus:ring-purple-300 transition-shadow shadow-inner"
          }),
          React.createElement('button', {
            onClick: handleStartClick,
            className: "p-4 px-10 text-xl sm:text-2xl rounded-2xl w-full max-w-sm bg-green-500 text-white font-bold transform hover:scale-105 hover:bg-green-600 active:scale-100 transition-all shadow-lg hover:shadow-xl"
          }, "B·∫Øt ƒë·∫ßu")
        );
      };

      // --- From components/TopicSelectionScreen.tsx ---
      const topicColors = [
        'from-red-500 to-red-600', 'from-blue-500 to-blue-600', 'from-green-500 to-green-600',
        'from-orange-500 to-orange-600', 'from-cyan-500 to-cyan-600', 'from-pink-500 to-pink-600',
      ];
      const TopicSelectionScreen = ({ topics, onSelectTopic }) => {
        return React.createElement('div', { className: "flex flex-col items-center gap-4 w-full animate-fade-in" },
          React.createElement('h2', { className: "text-2xl sm:text-3xl font-bold mb-4 text-slate-700" }, "Ch·ªçn m·ªôt ch·ªß ƒë·ªÅ ƒë·ªÉ h·ªçc:"),
          React.createElement('div', { className: "grid grid-cols-1 md:grid-cols-2 gap-5 w-full max-w-2xl" },
            topics.map((topic, index) => (
              React.createElement('button', {
                key: topic,
                onClick: () => onSelectTopic(topic),
                className: `p-4 text-lg text-white font-bold rounded-2xl transform hover:-translate-y-1 transition-all shadow-lg hover:shadow-xl bg-gradient-to-br ${topicColors[index % topicColors.length]}`
              }, topic)
            ))
          )
        );
      };

      // --- From components/GameScreen.tsx ---
      const shuffle = (array) => {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
      };
      const pastelColors = [
        'bg-sky-200 border-sky-400 text-sky-800 hover:bg-sky-300 hover:border-sky-500',
        'bg-emerald-200 border-emerald-400 text-emerald-800 hover:bg-emerald-300 hover:border-emerald-500',
        'bg-rose-200 border-rose-400 text-rose-800 hover:bg-rose-300 hover:border-rose-500',
        'bg-amber-200 border-amber-400 text-amber-800 hover:bg-amber-300 hover:border-amber-500',
        'bg-violet-200 border-violet-400 text-violet-800 hover:bg-violet-300 hover:border-violet-500',
        'bg-teal-200 border-teal-400 text-teal-800 hover:bg-teal-300 hover:border-teal-500',
      ];
      const GameScreen = ({ sentences, onTopicComplete, onChooseAnotherTopic }) => {
        const [currentIndex, setCurrentIndex] = useState(0);
        const [currentWords, setCurrentWords] = useState([]);
        const [shuffledWords, setShuffledWords] = useState([]);
        const [playerAnswer, setPlayerAnswer] = useState([]);
        const [mistakeCount, setMistakeCount] = useState(0);
        const [incorrectWord, setIncorrectWord] = useState(null);
        const [message, setMessage] = useState(null);
        const [score, setScore] = useState(0);
        const [correctlyAnswered, setCorrectlyAnswered] = useState(0);
        const [isSentenceDone, setIsSentenceDone] = useState(false);
        const [highlightedIndex, setHighlightedIndex] = useState(-1);
        const allowSecondPlay = useRef(true);
        const { speak, cancel, isSpeaking, voices } = useSpeechSynthesis();
        const [selectedVoiceURI, setSelectedVoiceURI] = useState(null);
        
        const selectedVoice = useMemo(() => {
          if (!voices || voices.length === 0) return null;
          if (selectedVoiceURI) {
            return voices.find(v => v.voiceURI === selectedVoiceURI);
          }
          return voices.find(v => v.name === 'Google US English') || voices.find(v => v.default) || voices[0];
        }, [voices, selectedVoiceURI]);

        useEffect(() => {
            if (voices.length > 0 && !selectedVoiceURI) {
                const defaultVoice = voices.find(v => v.name === 'Google US English') || voices.find(v => v.default) || voices[0];
                if (defaultVoice) {
                    setSelectedVoiceURI(defaultVoice.voiceURI);
                }
            }
        }, [voices, selectedVoiceURI]);

        const currentSentence = useMemo(() => sentences[currentIndex], [sentences, currentIndex]);

        const startNewSentence = useCallback(() => {
          if (currentIndex >= sentences.length) {
            onTopicComplete(correctlyAnswered, sentences.length);
            return;
          }
          setIsSentenceDone(false);
          setPlayerAnswer([]);
          setMistakeCount(0);
          setMessage(null);
          setHighlightedIndex(-1);
          const cleanSentence = sentences[currentIndex].en.replace(/[.!?]$/, '');
          const words = cleanSentence.split(' ');
          setCurrentWords(words);
          setShuffledWords(shuffle(words));
          allowSecondPlay.current = true;
          
          const speakOptions = { rate: 0.9, voice: selectedVoice };

          speak(sentences[currentIndex].en, {
              ...speakOptions,
              onEnd: () => {
                  if (allowSecondPlay.current) {
                      setTimeout(() => {
                          if (allowSecondPlay.current) speak(sentences[currentIndex].en, speakOptions);
                      }, 400);
                  }
              }
          });
        }, [currentIndex, sentences, onTopicComplete, correctlyAnswered, speak, selectedVoice]);
        
        const stopPendingActions = useCallback(() => {
          allowSecondPlay.current = false;
          cancel();
        }, [cancel]);

        useEffect(() => {
          startNewSentence();
          return stopPendingActions;
        }, [currentIndex]);
        
        useEffect(() => {
          return stopPendingActions;
        }, [stopPendingActions]);

        const handleListenAgain = () => {
          if (currentSentence) {
              stopPendingActions();
              speak(currentSentence.en, { rate: 0.9, voice: selectedVoice });
          }
        };

        const handleWordClick = (word, index) => {
          if (isSentenceDone) return;
          stopPendingActions();
          const correctWord = currentWords[playerAnswer.length];
          if (word === correctWord) {
            setPlayerAnswer([...playerAnswer, word]);
            setShuffledWords(prev => {
              const newArr = [...prev];
              const wordIndex = newArr.findIndex((w, i) => w === word && i === index);
              if (wordIndex > -1) newArr[wordIndex] = '';
              return newArr;
            });
            setMessage(null);
            if (playerAnswer.length + 1 === currentWords.length) {
              setIsSentenceDone(true);
              let newScore = score;
              let newCorrectlyAnswered = correctlyAnswered;
              if (mistakeCount <= 2) {
                newScore += 10;
                newCorrectlyAnswered++;
                setScore(newScore);
                setCorrectlyAnswered(newCorrectlyAnswered);
                setMessage({ text: 'Ch√≠nh x√°c! +10 ƒëi·ªÉm.', type: 'success' });
              } else {
                setMessage({ text: `B·∫°n ƒë√£ sai ${mistakeCount} l·∫ßn, kh√¥ng ƒë∆∞·ª£c c·ªông ƒëi·ªÉm c√¢u n√†y.`, type: 'error' });
              }
              speak(currentSentence.en, { 
                  voice: selectedVoice,
                  onBoundary: (wordIndex) => setHighlightedIndex(wordIndex),
                  onEnd: () => {
                    setHighlightedIndex(-1);
                    setTimeout(() => setCurrentIndex(prev => prev + 1), 2000);
                  }
              });
            }
          } else {
            setMistakeCount(prev => prev + 1);
            setIncorrectWord(`${word}-${index}`);
            setMessage({ text: `Sai r·ªìi! (S·ªë l·∫ßn sai: ${mistakeCount + 1})`, type: 'error' });
            setTimeout(() => setIncorrectWord(null), 500);
          }
        };

        return React.createElement('div', { className: "flex flex-col items-center gap-2 w-full animate-fade-in" },
          React.createElement('div', { className: "w-full text-center bg-purple-100/70 p-3 rounded-2xl" },
            React.createElement('div', { className: "text-xl sm:text-2xl text-purple-900 italic font-semibold" }, `‚Äú${currentSentence?.vi}‚Äù`)
          ),
          React.createElement('div', { className: "text-2xl sm:text-3xl font-bold mt-2 mb-1 min-h-[100px] bg-violet-50 p-4 rounded-xl shadow-inner w-full flex items-center justify-center flex-wrap gap-x-2.5 gap-y-3" },
            isSentenceDone ? 
              currentSentence.en.split(' ').map((word, index) => React.createElement('span', { key: index, className: `inline-block px-1 py-1 rounded-md transition-all duration-200 ${highlightedIndex === index ? 'bg-yellow-300 text-black scale-110' : 'bg-transparent text-slate-800 scale-100'}`}, word)) :
              currentWords.map((_, index) => React.createElement('div', { key: index, className: `h-16 w-24 flex items-center justify-center text-xl font-semibold p-2 rounded-lg ${playerAnswer[index] ? 'bg-purple-200 border-2 border-purple-500 text-purple-900' : 'bg-slate-200 border-2 border-dashed border-slate-400'}`}, playerAnswer[index]))
          ),
          React.createElement('div', { className: "min-h-[30px] text-xl font-bold" },
            message && React.createElement('p', { className: `${message.type === 'success' ? 'text-green-600' : 'text-red-500'}` }, message.text)
          ),
          React.createElement('div', { className: "flex flex-wrap justify-center gap-3 mt-1 mb-4 w-full min-h-[120px]" },
            shuffledWords.map((word, index) => {
              const isUsed = word === '';
              const isIncorrect = incorrectWord === `${word}-${index}`;
              const pastelColor = pastelColors[index % pastelColors.length];
              return React.createElement('button', {
                key: index,
                onClick: () => handleWordClick(word, index),
                disabled: isUsed || isSentenceDone,
                className: `text-xl font-bold py-3 px-5 rounded-xl border-b-4 transition-all duration-150 transform active:translate-y-0.5 active:border-b-2 ${isUsed ? 'opacity-0 pointer-events-none' : 'opacity-100'} ${isIncorrect ? 'border-red-500 animate-shake bg-red-100 text-red-600' : `${pastelColor} hover:-translate-y-1 hover:shadow-md`} ${isSentenceDone ? 'cursor-not-allowed' : ''}`
              }, word);
            })
          ),
          React.createElement('div', { className: "flex flex-wrap justify-center items-center gap-4 my-4" },
            React.createElement('button', { onClick: handleListenAgain, disabled: isSentenceDone || isSpeaking, className: "py-3 px-8 text-lg font-bold bg-purple-600 text-white rounded-xl shadow-md transform hover:-translate-y-1 transition-all disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none" }, "Nghe l·∫°i"),
             React.createElement('div', { className: "relative" },
                React.createElement('select', {
                  value: selectedVoiceURI || '',
                  onChange: (e) => setSelectedVoiceURI(e.target.value),
                  disabled: voices.length === 0 || isSpeaking,
                  'aria-label': "Ch·ªçn gi·ªçng ƒë·ªçc",
                  className: "py-3 px-5 text-lg font-bold bg-white text-slate-800 rounded-xl shadow-md appearance-none border-2 border-purple-300 focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all cursor-pointer disabled:bg-gray-200 disabled:cursor-not-allowed"
                },
                  voices.length === 0 ? 
                    React.createElement('option', {}, "T·∫£i gi·ªçng ƒë·ªçc...") :
                    voices.map(voice => React.createElement('option', { key: voice.voiceURI, value: voice.voiceURI }, voice.name))
                ),
                React.createElement('div', { className: "pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700" },
                  React.createElement('svg', { className: "fill-current h-4 w-4", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
                    React.createElement('path', { d: "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z" })
                  )
                )
            ),
            React.createElement('button', { onClick: onChooseAnotherTopic, className: "py-3 px-8 text-lg font-bold bg-yellow-500 text-slate-800 rounded-xl shadow-md transform hover:-translate-y-1 transition-all" }, "Ch·ªçn ch·ªß ƒë·ªÅ kh√°c")
          ),
          React.createElement('div', { className: "text-xl font-bold text-purple-800 mt-4" }, `ƒêi·ªÉm: ${score} | Ho√†n th√†nh: ${currentIndex}/${sentences.length}`)
        );
      };
      
      // --- From App.tsx ---
      const App = () => {
        const [gameState, setGameState] = useState(GameState.Start);
        const [playerName, setPlayerName] = useState('');
        const [selectedTopic, setSelectedTopic] = useState('');
        const [topicSentences, setTopicSentences] = useState([]);
        const [lastScore, setLastScore] = useState({ correct: 0, total: 0 });

        const handleStart = useCallback((name) => {
          setPlayerName(name);
          setGameState(GameState.TopicSelection);
        }, []);

        const handleSelectTopic = useCallback((topicName) => {
          setSelectedTopic(topicName);
          setTopicSentences(topics[topicName]);
          setGameState(GameState.Playing);
        }, []);

        const handleTopicComplete = useCallback((correct, total) => {
          setLastScore({ correct, total });
          setGameState(GameState.Congrats);
        }, []);
        
        const handlePlayAgain = useCallback(() => {
          if (selectedTopic && topics[selectedTopic]) {
            setTopicSentences(topics[selectedTopic]);
            setGameState(GameState.Playing);
          } else {
            setGameState(GameState.TopicSelection);
          }
        }, [selectedTopic]);

        const handleChooseAnotherTopic = useCallback(() => {
          setSelectedTopic('');
          setTopicSentences([]);
          setGameState(GameState.TopicSelection);
        }, []);

        const renderScreen = () => {
          switch (gameState) {
            case GameState.Start:
              return React.createElement(StartScreen, { onStart: handleStart });
            case GameState.TopicSelection:
              return React.createElement(TopicSelectionScreen, { topics: Object.keys(topics), onSelectTopic: handleSelectTopic });
            case GameState.Playing:
              return React.createElement(GameScreen, { key: selectedTopic, sentences: topicSentences, onTopicComplete: handleTopicComplete, onChooseAnotherTopic: handleChooseAnotherTopic });
            case GameState.Congrats:
              return React.createElement(TopicCongratsScreen, {
                  playerName: playerName,
                  topicName: selectedTopic,
                  correctCount: lastScore.correct,
                  totalCount: lastScore.total,
                  onPlayAgain: handlePlayAgain,
                  onChooseAnotherTopic: handleChooseAnotherTopic,
                });
            default:
              return React.createElement(StartScreen, { onStart: handleStart });
          }
        };

        return React.createElement('div', { className: "bg-gradient-to-br from-violet-100 to-sky-100 min-h-screen w-full flex justify-center items-center p-4" },
          React.createElement('main', { className: "container mx-auto text-center p-6 max-w-4xl w-full bg-white/90 backdrop-blur-sm rounded-3xl shadow-2xl shadow-violet-200" },
            React.createElement('h1', { className: "text-3xl sm:text-4xl md:text-5xl font-extrabold text-violet-600 mb-1 [text-shadow:_1px_2px_2px_rgb(0_0_0_/_10%)]" }, "NGHE V√Ä X·∫æP T·ª™ TH√ÄNH C√ÇU"),
            React.createElement('h2', { className: "text-xl sm:text-2xl md:text-3xl text-slate-500 font-semibold mb-5" }, "(H·ªèi & ƒê√°p)"),
            renderScreen()
          )
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(React.createElement(App));
    </script>
</body>
</html>
